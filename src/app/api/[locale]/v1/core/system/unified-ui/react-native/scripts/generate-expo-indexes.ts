#!/usr/bin/env bun
/* eslint-disable i18next/no-literal-string */
/**
 * Generate Expo Router index files from Next.js pages and layouts
 *
 * This script scans src/app/[locale] for page.tsx and layout.tsx files,
 * then creates corresponding index.tsx files in src/app-native/[locale]
 * that use the nextjs-compat-wrapper utilities.
 *
 * Features:
 * - Automatically detects all page.tsx and layout.tsx files
 * - Generates proper import paths
 * - Preserves existing files with "use-custom" directive
 * - Creates directory structure as needed
 * - Reports generation statistics
 *
 * Usage:
 *   bun scripts/generate-expo-indexes.ts
 */

import {
  existsSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  writeFileSync,
} from "fs";
import { dirname, join, relative } from "path";

import type { EndpointLogger } from "@/app/api/[locale]/v1/core/system/unified-ui/cli/vibe/endpoints/endpoint-handler/logger";
import { createEndpointLogger } from "@/app/api/[locale]/v1/core/system/unified-ui/cli/vibe/endpoints/endpoint-handler/logger";
import { defaultLocale } from "@/i18n/core/config";

// Bun-specific: import.meta.dir
declare global {
  interface ImportMeta {
    dir: string;
  }
}

const SCRIPT_DIR = import.meta.dir;
const PROJECT_ROOT = join(SCRIPT_DIR, "../../../..");
const SOURCE_DIR = join(PROJECT_ROOT, "src/app/[locale]");
const TARGET_DIR = join(SCRIPT_DIR, "../app/[locale]");

interface GenerationResult {
  created: string[];
  skipped: string[];
  errors: Array<{ file: string; error: string }>;
}

/**
 * Check if a file has the "use-custom" directive at the top
 * The directive must be on its own line, not part of other text
 */
function hasCustomIndexDirective(filePath: string): boolean {
  if (!existsSync(filePath)) {
    return false;
  }

  try {
    const content = readFileSync(filePath, "utf-8");
    // Check first 10 lines for the directive as a standalone marker
    const lines = content.split("\n").slice(0, 10);
    return lines.some((line) => {
      const trimmed = line.trim();
      // Match "use-custom" as a standalone directive (with or without comment markers)
      return (
        trimmed === '"use-custom"' ||
        trimmed === "'use-custom'" ||
        trimmed === "use-custom" ||
        trimmed === "// use-custom" ||
        trimmed === "// custom-index" ||
        trimmed === "* custom-index" ||
        trimmed === "* use-custom" ||
        trimmed === "/** custom-index" ||
        trimmed === " * custom-index"
      );
    });
  } catch {
    return false;
  }
}

/**
 * Generate the content for a page index.tsx file
 */
function generatePageIndex(
  relativePath: string,
  componentType: "page" | "layout",
): string {
  const wrapperType =
    componentType === "page" ? "createPageWrapper" : "createLayoutWrapper";
  const componentName =
    componentType === "page" ? "PageComponent" : "LayoutComponent";

  // Use absolute @/ import path
  const importPath = `@/app/[locale]${relativePath ? `/${relativePath}` : ""}/${componentType}`;

  return `/**
 * Expo Router compatibility wrapper for Next.js ${componentType}.tsx
 *
 * This file is auto-generated by scripts/generate-expo-indexes.ts
 * Do not edit manually unless you add a "use-custom" directive at the top.
 *
 * This wrapper handles:
 * - Async component loading (Next.js ${componentType}s can be async Server Components)
 * - URL params conversion (Next.js uses async params, Expo Router uses hooks)
 * - Loading states with ActivityIndicator
 * - Error handling
 * - Type-safe params forwarding
 */

import ${componentName} from "${importPath}";

import { ${wrapperType} } from "@/app/api/[locale]/v1/core/system/unified-ui/react-native/utils";

/**
 * Wrapper component that converts Expo Router's synchronous params
 * to Next.js 15's async params format
 */
export default ${wrapperType}(${componentName});
`;
}

/**
 * Ensure directory exists, creating it if necessary
 */
function ensureDir(dirPath: string): void {
  if (!existsSync(dirPath)) {
    mkdirSync(dirPath, { recursive: true });
  }
}

/**
 * Recursively find all files matching a pattern
 */
function findFiles(dir: string, pattern: string, basePath = ""): string[] {
  const results: string[] = [];

  try {
    const entries = readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      const relativePath = basePath ? join(basePath, entry.name) : entry.name;

      if (entry.isDirectory()) {
        results.push(...findFiles(fullPath, pattern, relativePath));
      } else if (entry.isFile() && entry.name === pattern) {
        results.push(relativePath);
      }
    }
  } catch {
    // Ignore errors (permission denied, etc.)
  }

  return results;
}

/**
 * Generate index files for all pages and layouts
 */
function generateIndexes(logger: EndpointLogger): GenerationResult {
  const result: GenerationResult = {
    created: [],
    skipped: [],
    errors: [],
  };

  logger.debug("\nðŸ” Scanning for Next.js pages and layouts...\n", "bright");

  // Find all page.tsx and layout.tsx files
  const pageFiles = findFiles(SOURCE_DIR, "page.tsx");
  const layoutFiles = findFiles(SOURCE_DIR, "layout.tsx");

  logger.debug(
    `Found ${pageFiles.length} pages and ${layoutFiles.length} layouts\n`,
    "cyan",
  );

  // Process pages
  for (const pageFile of pageFiles) {
    const relativePath = dirname(pageFile);
    const targetPath = join(TARGET_DIR, relativePath, "index.tsx");

    try {
      // Check for custom-index directive
      if (hasCustomIndexDirective(targetPath)) {
        logger.debug(
          `â­ï¸  Skipped (custom-index): ${relativePath}/index.tsx`,
          "yellow",
        );
        result.skipped.push(relativePath);
        continue;
      }

      // Ensure directory exists
      ensureDir(dirname(targetPath));

      // Generate content
      const content = generatePageIndex(
        relativePath === "." ? "" : relativePath,
        "page",
      );

      // Write file
      writeFileSync(targetPath, content, "utf-8");

      logger.debug(`âœ… Generated: ${relativePath}/index.tsx`, "green");
      result.created.push(relativePath);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      logger.debug(
        `âŒ Error: ${relativePath}/index.tsx - ${errorMessage}`,
        "yellow",
      );
      result.errors.push({ file: relativePath, error: errorMessage });
    }
  }

  // Process layouts (only if there's no corresponding page)
  for (const layoutFile of layoutFiles) {
    const relativePath = dirname(layoutFile);
    const targetPath = join(TARGET_DIR, relativePath, "index.tsx");

    // Skip if there's already an index from a page
    if (existsSync(targetPath)) {
      continue;
    }

    try {
      // Check for custom-index directive
      if (hasCustomIndexDirective(targetPath)) {
        logger.debug(
          `â­ï¸  Skipped (custom-index): ${relativePath}/_layout.tsx`,
          "yellow",
        );
        result.skipped.push(relativePath);
        continue;
      }

      // Ensure directory exists
      ensureDir(dirname(targetPath));

      // Generate content for layout
      const content = generatePageIndex(
        relativePath === "." ? "" : relativePath,
        "layout",
      );

      // Write file with _layout.tsx naming convention
      const layoutTargetPath = join(TARGET_DIR, relativePath, "_layout.tsx");
      writeFileSync(layoutTargetPath, content, "utf-8");

      logger.debug(`âœ… Generated: ${relativePath}/_layout.tsx`, "green");
      result.created.push(relativePath);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      logger.debug(
        `âŒ Error: ${relativePath}/_layout.tsx - ${errorMessage}`,
        "yellow",
      );
      result.errors.push({ file: relativePath, error: errorMessage });
    }
  }

  return result;
}

/**
 * Print summary statistics
 */
function printSummary(result: GenerationResult, logger: EndpointLogger): void {
  logger.debug(`\n${"=".repeat(60)}`, "gray");
  logger.debug("ðŸ“Š Generation Summary", "bright");
  logger.debug(`${"=".repeat(60)}\n`, "gray");

  logger.debug(`âœ… Created:  ${result.created.length} files`, "green");
  logger.debug(
    `â­ï¸  Skipped:  ${result.skipped.length} files (custom-index)`,
    "yellow",
  );
  logger.debug(
    `âŒ Errors:   ${result.errors.length} files\n`,
    result.errors.length > 0 ? "yellow" : "green",
  );

  if (result.errors.length > 0) {
    logger.debug("Error details:", "yellow");
    for (const { file, error } of result.errors) {
      logger.debug(`  â€¢ ${file}: ${error}`, "gray");
    }
    logger.debug("");
  }

  logger.debug(`${"=".repeat(60)}\n`, "gray");
}

/**
 * Main execution
 */
function main(): void {
  const logger = createEndpointLogger(true, Date.now(), defaultLocale);
  logger.debug("\nðŸš€ Expo Router Index Generator", "bright");
  logger.debug(`${"=".repeat(60)}\n`, "gray");

  logger.debug(`ðŸ“ Source:     ${relative(PROJECT_ROOT, SOURCE_DIR)}`, "blue");
  logger.debug(
    `ðŸ“ Target:     ${relative(PROJECT_ROOT, TARGET_DIR)}\n`,
    "blue",
  );

  // Check if source directory exists
  if (!existsSync(SOURCE_DIR)) {
    logger.debug(
      `âŒ Error: Source directory not found: ${SOURCE_DIR}`,
      "yellow",
    );
    process.exit(1);
  }

  // Ensure target directory exists
  ensureDir(TARGET_DIR);

  // Generate indexes
  const result = generateIndexes(logger);

  // Print summary
  printSummary(result, logger);

  // Exit with error code if there were errors
  if (result.errors.length > 0) {
    process.exit(1);
  }

  logger.debug("âœ¨ All done!", "green");
}

// Run the script
main();
