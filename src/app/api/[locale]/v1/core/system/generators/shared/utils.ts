/**
 * Shared Generator Utilities
 * Simple utilities for all generators
 */

import "server-only";

import { existsSync, mkdirSync, readdirSync } from "node:fs";
import { writeFile } from "node:fs/promises";
import { dirname, join, relative } from "node:path";

/**
 * Default directories to exclude from scanning
 */
export const DEFAULT_EXCLUDE_DIRS = [
  "node_modules",
  ".git",
  ".next",
  "dist",
  ".dist",
  "generated",
];

/**
 * Recursively find files with specific filename in a directory
 */
export function findFilesRecursively(
  dir: string,
  targetFilename: string,
  excludeDirs: string[] = DEFAULT_EXCLUDE_DIRS,
): string[] {
  const results: string[] = [];

  if (!existsSync(dir)) {
    return results;
  }

  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);

    // Skip excluded directories
    if (entry.isDirectory() && excludeDirs.includes(entry.name)) {
      continue;
    }

    if (entry.isDirectory()) {
      // Recursively search subdirectories
      results.push(
        ...findFilesRecursively(fullPath, targetFilename, excludeDirs),
      );
    } else if (entry.isFile() && entry.name === targetFilename) {
      // Found a matching file
      results.push(fullPath);
    }
  }

  return results;
}

/**
 * Get relative import path from source file to output file
 */
export function getRelativeImportPath(
  sourceFile: string,
  outputFile: string,
): string {
  const outputDir = dirname(outputFile);
  let relativePath = relative(outputDir, sourceFile);

  // Remove .ts extension and normalize path separators
  relativePath = relativePath.replace(/\.ts$/, "").replace(/\\/g, "/");

  // Ensure it starts with ./ or ../
  if (!relativePath.startsWith(".")) {
    relativePath = `./${relativePath}`;
  }

  return relativePath;
}

/**
 * Extract nested path segments from a file path
 * Example: src/app/api/[locale]/v1/core/agent/chat/personas/definition.ts
 * Returns: ["core", "agent", "chat", "personas"]
 */
export function extractNestedPath(
  filePath: string,
  startMarker = "v1",
  endMarker = "definition.ts",
): string[] {
  const pathParts = filePath.split("/");

  const startIndex = pathParts.findIndex((p) => p === startMarker);
  if (startIndex === -1) {
    throw new Error(`Could not find ${startMarker} in path: ${filePath}`);
  }

  const endIndex = pathParts.findIndex((p) => p === endMarker);
  if (endIndex === -1) {
    throw new Error(`Could not find ${endMarker} in path: ${filePath}`);
  }

  return pathParts.slice(startIndex + 1, endIndex);
}

/**
 * Extract module name from file path
 * Example: .../core/leads/seeds.ts -> "leads"
 * Example: .../core/emails/smtp-client/seeds.ts -> "smtp-client"
 */
export function extractModuleName(
  filePath: string,
  coreMarker = "core",
): string {
  const pathParts = filePath.split("/");
  const coreIndex = pathParts.findIndex((p) => p === coreMarker);

  if (coreIndex === -1 || coreIndex >= pathParts.length - 1) {
    return pathParts[pathParts.length - 2] || "unknown";
  }

  const moduleParts = pathParts.slice(coreIndex + 1, pathParts.length - 1);
  return moduleParts[moduleParts.length - 1] || moduleParts.join("-");
}

/**
 * Write generated content to file
 */
export async function writeGeneratedFile(
  filePath: string,
  content: string,
  dryRun = false,
): Promise<void> {
  if (dryRun) {
    return;
  }

  const outputDir = dirname(filePath);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  await writeFile(filePath, content, "utf8");
}

/**
 * Generate standard file header
 */
export function generateFileHeader(
  title: string,
  generatedBy: string,
  additionalInfo?: Record<string, string | number>,
): string {
  const lines = ["/**"];
  lines.push(` * ${title}`);
  lines.push(` * Generated by ${generatedBy}`);

  if (additionalInfo) {
    lines.push(" *");
    for (const [key, value] of Object.entries(additionalInfo)) {
      lines.push(` * ${key}: ${value}`);
    }
  }

  lines.push(` * Generated at: ${new Date().toISOString()}`);
  lines.push(" */");

  return lines.join("\n");
}
