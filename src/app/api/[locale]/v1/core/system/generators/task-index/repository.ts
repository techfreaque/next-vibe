/**
 * Task Index Generator Repository
 * Handles task index generation functionality
 */

/* eslint-disable i18next/no-literal-string */
// CLI output messages don't need internationalization

import "server-only";

import { existsSync, mkdirSync } from "node:fs";
import { writeFile } from "node:fs/promises";
import { dirname, relative } from "node:path";

import type { ResponseType as BaseResponseType } from "next-vibe/shared/types/response.schema";
import {
  createErrorResponse,
  createSuccessResponse,
  ErrorResponseTypes,
} from "next-vibe/shared/types/response.schema";
import { parseError } from "next-vibe/shared/utils/parse-error";

import type { CountryLanguage } from "@/i18n/core/config";

import type { JwtPayloadType } from "../../../user/auth/definition";
import type { EndpointLogger } from "../../unified-ui/cli/vibe/endpoints/endpoint-handler/logger/types";
import type endpoints from "./definition";

type RequestType = typeof endpoints.POST.types.RequestOutput;
type TaskIndexResponseType = typeof endpoints.POST.types.ResponseOutput;

/**
 * Task Index Generator Repository Interface
 */
interface TaskIndexGeneratorRepository {
  generateTaskIndex(
    data: RequestType,
    user: JwtPayloadType,
    locale: CountryLanguage,
    logger: EndpointLogger,
  ): Promise<BaseResponseType<TaskIndexResponseType>>;
}

/**
 * Task Index Generator Repository Implementation
 */
class TaskIndexGeneratorRepositoryImpl implements TaskIndexGeneratorRepository {
  async generateTaskIndex(
    data: RequestType,
    _user: JwtPayloadType,
    _locale: CountryLanguage,
    logger: EndpointLogger,
  ): Promise<BaseResponseType<TaskIndexResponseType>> {
    const startTime = Date.now();

    try {
      const outputFile = data.outputFile;

      // Create output directory if it doesn't exist
      const outputDir = dirname(outputFile);
      if (!existsSync(outputDir)) {
        mkdirSync(outputDir, { recursive: true });
      }

      // Discover task files (unified format as per spec.md)
      const taskFiles = await this.discoverTaskFiles();
      const taskRunnerFiles = await this.discoverTaskRunnerFiles();
      const sideTaskFiles = await this.discoverSideTaskConfigs();

      logger.debug(
        `Found ${taskFiles.length} task.ts files, ${taskRunnerFiles.length} task-runner.ts files, and ${sideTaskFiles.length} side-task config files`,
      );

      // Validate discovered files
      const validationResult = await this.validateTaskFiles(
        taskFiles,
        taskRunnerFiles,
        sideTaskFiles,
        logger,
      );
      if (!validationResult.success) {
        return createErrorResponse(
          "error.errorTypes.validation_error",
          ErrorResponseTypes.VALIDATION_ERROR,
          { error: validationResult.error || "Validation failed" },
        );
      }

      // Generate imports
      const imports: string[] = [];
      const taskExports: string[] = [];
      const taskRunnerExports: string[] = [];

      let moduleIndex = 0;

      // Process task.ts files (new unified format)
      for (const taskFile of taskFiles) {
        const relativePath = this.getRelativeImportPath(taskFile, outputFile);
        imports.push(
          `import { tasks as taskModule${moduleIndex} } from "${relativePath}";`,
        );
        taskExports.push(`  ...taskModule${moduleIndex},`);
        moduleIndex++;
      }

      // Process task-runner.ts files
      for (const runnerFile of taskRunnerFiles) {
        const relativePath = this.getRelativeImportPath(runnerFile, outputFile);
        imports.push(
          `import { taskRunners as runnerModule${moduleIndex} } from "${relativePath}";`,
        );
        taskRunnerExports.push(`  ...runnerModule${moduleIndex},`);
        moduleIndex++;
      }

      // Process side-task configuration files
      for (const sideTaskFile of sideTaskFiles) {
        const relativePath = this.getRelativeImportPath(
          sideTaskFile,
          outputFile,
        );
        imports.push(
          `import { sideTaskConfigs as sideTaskModule${moduleIndex} } from "${relativePath}";`,
        );
        taskExports.push(`  ...sideTaskModule${moduleIndex},`);
        moduleIndex++;
      }

      // Generate task index content with proper import paths and enhanced metadata
      const content = `/**
 * AUTO-GENERATED TASK INDEX
 * Generated by Task Index Generator
 * Implements spec.md unified task registry requirements
 *
 * Generation Info:
 * - Task files: ${taskFiles.length}
 * - Task runner files: ${taskRunnerFiles.length}
 * - Side task config files: ${sideTaskFiles.length}
 * - Generated at: ${new Date().toISOString()}
 */

/* eslint-disable prettier/prettier */
/* eslint-disable simple-import-sort/imports */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */

import type { Task, TaskRegistry } from "../types/repository";
import { UnifiedTaskRunnerRepositoryImpl } from "../unified-runner/repository";

${imports.join("\n")}

const allTasks: Task[] = [
${taskExports.join("\n")}
${taskRunnerExports.join("\n")}
];

const cronTasks = allTasks.filter((task): task is Task & { type: 'cron' } => task.type === 'cron');
const sideTasks = allTasks.filter((task): task is Task & { type: 'side' } => task.type === 'side');
const taskRunners = allTasks.filter((task): task is Task & { type: 'task-runner' } => task.type === 'task-runner');

const tasksByCategory = allTasks.reduce((acc, task) => {
  const category = task.category as string;
  if (!acc[category]) {
    acc[category] = [];
  }
  acc[category].push(task);
  return acc;
}, {} as Record<string, Task[]>);

const tasksByName = allTasks.reduce((acc, task) => {
  acc[task.name] = task;
  return acc;
}, {} as Record<string, Task>);

// Create single unified task runner instance as per spec.md
const taskRunner = new UnifiedTaskRunnerRepositoryImpl();

export const taskRegistry: TaskRegistry = {
  cronTasks,
  sideTasks,
  taskRunners,
  allTasks,
  tasksByCategory,
  tasksByName,
  taskRunner, // Single unified task runner instance
};

export { allTasks, cronTasks, sideTasks, taskRunners, tasksByCategory, tasksByName, taskRunner };
export default allTasks;
`;

      if (!data.dryRun) {
        await writeFile(outputFile, content, "utf8");
      }

      const duration = Date.now() - startTime;
      const tasksFound = taskFiles.length + taskRunnerFiles.length;

      return createSuccessResponse({
        success: true,
        message: `Generated task index with ${tasksFound} task files in ${duration}ms`,
        tasksFound,
        duration,
        outputFile: data.dryRun ? undefined : outputFile,
      });
    } catch (error) {
      const duration = Date.now() - startTime;
      return createErrorResponse(
        "error.errorTypes.internal_error",
        ErrorResponseTypes.INTERNAL_ERROR,
        {
          error: `Task index generation failed: ${parseError(error).message}`,
          duration,
        },
      );
    }
  }

  /**
   * Discover all task.ts files in the codebase (unified format as per spec.md)
   * These files export tasks array with CronTask, SideTask, or TaskRunner objects
   */
  private async discoverTaskFiles(): Promise<string[]> {
    const { glob } = await import("glob");
    const taskFiles = await glob("src/app/api/**/task.ts", {
      cwd: process.cwd(),
      absolute: true,
    });
    return taskFiles;
  }

  /**
   * Discover all task-runner.ts files in the codebase
   * These are specialized side tasks that manage other tasks
   */
  private async discoverTaskRunnerFiles(): Promise<string[]> {
    const { glob } = await import("glob");
    const runnerFiles = await glob("src/app/api/**/*task-runner.ts", {
      cwd: process.cwd(),
      absolute: true,
    });
    return runnerFiles;
  }

  /**
   * Discover side task configuration files
   * These files export sideTaskConfigs array as per spec.md
   */
  private async discoverSideTaskConfigs(): Promise<string[]> {
    const { glob } = await import("glob");
    const fs = await import("fs/promises");

    // Look for files that might contain side task configurations
    const candidateFiles = await glob("src/app/api/**/side-tasks.ts", {
      cwd: process.cwd(),
      absolute: true,
    });

    const sideTaskFiles: string[] = [];

    for (const file of candidateFiles) {
      try {
        const content = await fs.readFile(file, "utf-8");
        // Check if file exports sideTaskConfigs
        if (
          content.includes("export const sideTaskConfigs") ||
          content.includes("export { sideTaskConfigs }")
        ) {
          sideTaskFiles.push(file);
        }
      } catch {
        // Skip files that can't be read
        continue;
      }
    }

    return sideTaskFiles;
  }

  /**
   * Validate discovered task files
   * Ensures files export the expected interfaces as per spec.md
   */
  private async validateTaskFiles(
    taskFiles: string[],
    taskRunnerFiles: string[],
    sideTaskFiles: string[],
    logger: EndpointLogger,
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const fs = await import("fs/promises");

      // Validate task.ts files
      for (const file of taskFiles) {
        try {
          const content = await fs.readFile(file, "utf-8");

          // Check for required exports
          if (
            !content.includes("export const tasks") &&
            !content.includes("export { tasks }")
          ) {
            return {
              success: false,
              error: `Task file ${file} must export 'tasks' array`,
            };
          }

          // Check for legacy exports (backward compatibility)
          const hasLegacyExports =
            content.includes("export const taskDefinition") ||
            content.includes("export const execute");

          if (hasLegacyExports) {
            logger.debug(
              `Task file ${file} has legacy exports - ensure unified format is also present`,
            );
          }
        } catch (error) {
          return {
            success: false,
            error: `Failed to validate task file ${file}: ${parseError(error).message}`,
          };
        }
      }

      // Validate task-runner.ts files
      for (const file of taskRunnerFiles) {
        try {
          const content = await fs.readFile(file, "utf-8");

          if (
            !content.includes("export const taskRunners") &&
            !content.includes("export { taskRunners }")
          ) {
            return {
              success: false,
              error: `Task runner file ${file} must export 'taskRunners' array`,
            };
          }
        } catch (error) {
          return {
            success: false,
            error: `Failed to validate task runner file ${file}: ${parseError(error).message}`,
          };
        }
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: `Task file validation failed: ${parseError(error).message}`,
      };
    }
  }

  /**
   * Get relative import path from task file to output file
   */
  private getRelativeImportPath(taskFile: string, outputFile: string): string {
    const outputDir = dirname(outputFile);
    let relativePath = relative(outputDir, taskFile);

    // Remove .ts extension and normalize path separators
    relativePath = relativePath.replace(/\.ts$/, "").replace(/\\/g, "/");

    // Ensure it starts with ./ or ../
    if (!relativePath.startsWith(".")) {
      relativePath = `./${relativePath}`;
    }

    return relativePath;
  }
}

export const taskIndexGeneratorRepository =
  new TaskIndexGeneratorRepositoryImpl();
